<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Performance</title>
    <link rel="preconnect" href="https://fonts.gstatic.com" />
    <link
      href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <link type="text/css" rel="stylesheet" href="css/topic.css" />
  </head>
  <body>
    <header id="main-header">
      <a href="index.html" id="logo">System Design</a>
      <nav>
        <ul>
          <li><a href="">Books</a></li>
          <li><a href="">Courses</a></li>
        </ul>
      </nav>
      <a href="#side-drawer" class="menu-btn"
        ><span></span><span></span><span></span
      ></a>
    </header>
    <aside id="side-drawer">
      <header id="sub-header">
        <a href="refresher.html" id="sublogo">Performance</a>
        <a href="#" class="menu-btn"><span></span><span></span><span></span></a>
      </header>
      <nav>
        <ul>
          <li><a href="">Books</a></li>
          <li><a href="">Courses</a></li>
        </ul>
      </nav>
    </aside>
    <main>
      <h1>Performance</h1>
      <section></section>
      <section id="latest-products">
        <ul>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Architectural Values</h2>
                <p>
                  We looked at the structure (or architecture) and behaviour
                  <a href="cleanarch.html">before</a>. The major considerations
                  under architecture are as below.
                </p>

                <p>
                  A 'software' is supposed to be soft. That is, it should be
                  easy to change. The difficulty in making the change should be
                  proprtional to the scope of the change, not to the shape of
                  the change. The structure determines impact of shape on a
                  change.
                  <strong
                    >Is it more important for the software system to work or is
                    it more important for the software system to be accomodative
                    of changes?</strong
                  >
                </p>
                <p>
                  If we have a program that works, but is impossible to change,
                  then it will stop working when there is a change in
                  requirement. Unless you are living in a world of certainity,
                  where you know how the program should behave for the next 100
                  years, you should consider shape agnostic structure of
                  software programs to be more important than behaviour.
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Matrix</h2>

                <img src="./img/Matrix.jpg" />
                <p>
                  The strucuture of the code is in the first two positions of
                  priority and the behaviour of code is in the first and the
                  third positions of priority. The mistake that we often make is
                  to elevate the priority 3 items to priority 1. This leads to
                  ignoring the important architectural elements of the system in
                  favor of the unimportant features. Since, business is detached
                  from the architecture of a system, it is the responsibility of
                  the developers to assert the importance of structure over
                  behaviour.
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Three Paradigms</h2>
                <p>
                  The three paradigms in programming are
                  <strong
                    >structured, object oriented and functional
                    programming</strong
                  >. Dijkstra prohibited the go to statements and invented
                  structured programming â€”in which programs flow from top to
                  bottom following a hierarchical model. Structured programming
                  imposes discipline on direct flow of control.
                </p>
                <p>
                  Object Oriented Programming originated when the developers
                  realized the variables in the stack can be be stored in a heap
                  and can be reused after the function returns. The function can
                  be used as the constructor of the class. Object Oriented
                  Programming imposes discipline on indirect transfer of
                  control.
                </p>
                <p>
                  Functional programming is an extension of lambda calculus. The
                  foundation of lambda calculus is the immutability of
                  variables. Functional imposes discipline upon assignment of
                  values. Most functional languages will have restricted means
                  of assigning values.
                </p>
                <p>
                  The three paradigms take away go to statements, function
                  pointers and assignment. There is probably nothing more to
                  take away from the developers and that may be why we aren't
                  seeing any new paradigms.
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Structured Programming</h2>
                <p>
                  Dijkstra found out that certain usage of 'go to' statement
                  prevents the decomposition of a module recursively in to
                  smaller units. This prevents developers from employing divide
                  and conquer approach of reducing system complexity.
                </p>
                <p>
                  So, Edgar Dijkstra published a paper stating
                  <a
                    href="https://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf"
                    target="_blank"
                    >Go To statement is harmful</a
                  >. This led to the removal for 'go to' statements from modern
                  languages and allowed the programmers to decompose a large
                  scale problems into small functions. Dijkstra initially
                  thought of strucutred programming to be accompanied by
                  mathematical euclidean proofs. But, programming moved towards
                  verification scientific observations (a.k.a tests) in its
                  further evolution.
                </p>
                <p>
                  Dijkstra once said a test can prove the presence of bugs, but
                  not the absence of them. A program can be proven incorrect by
                  a test, but it cannot be proven correct by a test. So,
                  software development is not a mathematical endevor. Rather, it
                  is a science where we show corrects by failing to prove
                  incorrects.
                </p>
                <p>
                  The above proof of incorrects is possible only on provable
                  sttructured programs. You cannot show corrects by failing to
                  prove incorrects in a code full of 'go to' statements.
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Object Oriented Programming</h2>
                <p>
                  Dijkstra found out that certain usage of 'go to' statement
                  prevents the decomposition of a module recursively in to
                  smaller units. This prevents developers from employing divide
                  and conquer approach of reducing system complexity.
                </p>
                <p>
                  So, Edgar Dijkstra published a paper stating
                  <a
                    href="https://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf"
                    target="_blank"
                    >Go To statement is harmful</a
                  >. This led to the removal for 'go to' statements from modern
                  languages and allowed the programmers to decompose a large
                  scale problems into small functions. Dijkstra initially
                  thought of strucutred programming to be accompanied by
                  mathematical euclidean proofs. But, programming moved towards
                  verification scientific observations (a.k.a tests) in its
                  further evolution.
                </p>
                <p>
                  Dijkstra once said a test can prove the presence of bugs, but
                  not the absence of them. A program can be proven incorrect by
                  a test, but it cannot be proven correct by a test. So,
                  software development is not a mathematical endevor. Rather, it
                  is a science where we show corrects by failing to prove
                  incorrects.
                </p>
                <p>
                  The above proof of incorrects is possible only on provable
                  sttructured programs. You cannot show corrects by failing to
                  prove incorrects in a code full of 'go to' statements.
                </p>
              </div>
            </article>
          </li>
        </ul>
      </section>
    </main>

    <footer></footer>
  </body>
</html>
