<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Graph Database</title>
    <link rel="preconnect" href="https://fonts.gstatic.com" />
    <link
      href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <link type="text/css" rel="stylesheet" href="css/topic.css" />
  </head>
  <body>
    <header id="main-header">
      <a href="index.html" id="logo">Data Intensive Apps</a>
      <nav>
        <ul>
          <li><a href="">Books</a></li>
          <li><a href="">Courses</a></li>
        </ul>
      </nav>
      <a href="#side-drawer" class="menu-btn"
        ><span></span><span></span><span></span
      ></a>
    </header>
    <aside id="side-drawer">
      <header id="sub-header">
        <a href="index.html" id="sublogo">Data Intensive Apps</a>
        <a href="#" class="menu-btn"><span></span><span></span><span></span></a>
      </header>
      <nav>
        <ul>
          <li><a href="">Books</a></li>
          <li><a href="">Courses</a></li>
        </ul>
      </nav>
    </aside>
    <main>
      <h1>Graph Database</h1>
      <section id="latest-products">
        <ul>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Graph Tables</h2>
                <p>
                  Relational data models primarily serve the purpose of storing
                  data with one-to-one, one-to-many and simple many-to-many
                  relationships. The one-to-one and one-to-many relationships
                  are also well managed by document databases like MongoDB.
                </p>
                <p>
                  But, these two data bases do not have an easy answer for
                  complex many-to-many relationships in the data. As the
                  connections between our data gets more and more sophisticated,
                  it becomes natural to model the data as graph.
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Nodes and Relationships</h2>
                <p>
                  A graph consists of two different kinds of objects: nodes
                  <em>(or vertices or entities)</em> and relationships
                  <em>(or edges or arcs)</em>. Similar type of nodes are clubbed
                  together under a label. So, you can think of nodes as records
                  in a RDMS table and label as the table itself.
                </p>
                <p>
                  Unlike RDMS, where relationships are defined at the table
                  level, the relationships in Graph DB can be defined at the
                  node level.
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Properties</h2>
                <p>
                  We can assign the properties to nodes and relationships. A
                  relationship will have a direction and a label. The label will
                  say something like 'belongs to', 'travelling to' etc.
                </p>
                <p>
                  For instance, we can have a node with properties
                  <code>{name: "John", ...}</code> or
                  <code>{name: "Peter", ...}</code>. Those nodes can have
                  multiple labels, like citizens, employees etc. But,
                  relationships can have only one label.
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Neo4j</h2>
                <p>
                  Neo4j is the most popular enterprise strength graph database
                  in use. It is a schema on read database. So, the properties of
                  nodes and relationships can differ under similar label.
                </p>
                <p>
                  Neo4j does not allow nested properties for node and
                  relationship. The easiest way to create and access Graph DBs
                  is to install Neo4j Desktop by going to neo4j.com ->
                  Developers -> Download Center.
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Neo4j Browser</h2>
                <p>
                  Once the neo4j desktop is installed, create a new project, a
                  new DBMS and start the DBMS. The DBMS will be running in the
                  local and will be exposed in the port 7474. You can click on
                  open button next to the DBMS. It will have an option to open
                  the Neo4j browser.
                </p>
                <p>
                  So, now you have two applications running on your machine,
                  Neo4j Desktop and Neo4j Browser. You can also open the Neo4j
                  browser through http://localhost:7474/.
                  <code class="language-text">create database</code> will create
                  the database under the DBMS created before.<code
                    class="language-text"
                    >:use database-name</code
                  >
                  will switch to database-name.
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Cypher QL</h2>
                <p>
                  The query language used in the Neo4j is the Cypher (after
                  matrix character) Query Language or CQL.
                  <code class="language-text">drop database db-name</code> is
                  the CQL for dropping database-name.
                </p>
                <p>
                  CQL refers to node with parantheses. So,
                  <code class="language-text">create()</code> will create a node
                  without any label or properties.<code class="language-text"
                    >create(:Author)</code
                  >
                  will create a node with the label Author.
                  <code class="language-text">create(:Author:Reader)</code> will
                  create a node with two labels Author and Reader. If you want
                  the created node to be returned right away, use an alias and
                  return the alias as in
                  <code class="language-text"
                    >create(aliasrt:Author:Reader) return(aliasrt)</code
                  >
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Viewing Nodes</h2>
                <p>
                  The nodes can be viewed in the graphical mode in the Neo4j
                  browser. We can also view them in table format.
                </p>
                <p>
                  <code class="language-text">create(:Author)</code> node would
                  have been structured as below in the table view<code
                    ><br />{<br />
                    "identity": 0,<br />
                    "labels": [<br />
                    "Author"<br />],<br />
                    "properties": {<br />
                    },<br />
                    "elementId": "0"<br />
                    }<br
                  /></code>
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Creating with Properties</h2>
                <p>
                  Now, let us add some properties to a node and create it under
                  Author label.
                  <code class="language-text"
                    >create(:Author {firstName: "Betrand", lastName:
                    "Russel"})</code
                  >
                  will create the node as below
                  <code
                    ><br />{<br />
                    &nbsp;&nbsp;"identity": 3,<br />
                    &nbsp;&nbsp;"labels": [<br />
                    &nbsp;&nbsp;"Author"<br />&nbsp;&nbsp;&nbsp;&nbsp;],<br />
                    &nbsp;&nbsp;"properties": {,<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;"firstName": "Betrand",,<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;"lastName": "Russel",<br />
                    &nbsp;&nbsp;},<br />
                    &nbsp;&nbsp;"elementId": "3"<br />
                    }<br
                  /></code>
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Filtering Nodes</h2>
                <p>
                  <code class="language-text"
                    >match (abc:Author) return abc</code
                  >
                  will retrieve only the nodes with the label as Author.
                </p>
                <p>
                  <code class="language-text"
                    >match (abc:Author:Reader) return abc</code
                  >
                  will retrieve the nodes with the label as Author
                  <strong>and</strong> Reader.
                </p>
                <p>
                  <code class="language-text"
                    >match(abc{firstName:"Bertrand"}) return abc</code
                  >
                  will retrieve all the nodes with the firstName property as
                  Bertrand
                </p>
                <p>
                  <code class="language-text"
                    >match(abc{firstName:"Bertrand", lastName:"Russel"}) return
                    abc</code
                  >
                  will retrieve all the nodes with the firstName property as
                  Bertrand <strong>and</strong> lastName as Russel.
                </p>
                <p>
                  <code class="language-text"
                    >match(abc:Author{firstName:"Bertrand", lastName:"Russel"})
                    return abc</code
                  >
                  will retrieve all the nodes with label as Author
                  <strong>and</strong> firstName property as Bertrand
                  <strong>and</strong> lastName as Russel.
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">WHERE Condition</h2>
                <p>
                  You can also use where clause to retrieve nodes from the
                  database. For example,
                  <code class="language-text"
                    >match(abc:Author) where abc.firstName = "Betrand" and
                    abc.lastName = "Russel" return abc</code
                  >
                  will retrieve all the nodes with label as Author
                  <strong>and</strong> firstName property as Bertrand
                  <strong>and</strong> lastName as Russel.
                </p>
                <p>
                  In the same way, we can use OR condition as below.
                  <code class="language-text"
                    >match(abc:Author) where abc.firstName = "Betrand" OR
                    abc.firstName = "Bertrand" return abc</code
                  >
                  will retrieve all the nodes with label as Author
                  <strong>and</strong> firstName property as Bertrand
                  <strong>OR</strong> firstName as Bertrand.
                </p>
                <p>
                  We can also use IN condition as below.
                  <code class="language-text"
                    >match(abc:Author) where abc.lastName IN ["Russel"] return
                    abc</code
                  >
                  will retrieve all the nodes with label as Author
                  <strong>and</strong> lastName as Russel.
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Select by ID</h2>
                <p>
                  If you try selecting using the default attributes (like
                  elementId or identity) using<code class="language-text"
                    >match(abc{identity:3}) return abc</code
                  >then you will get an error stating "The provided property key
                  is not in the database".
                </p>
                <p>
                  The right way to retrieve using system assgined IDs is
                  <code class="language-text"
                    >match(abc) where ID(abc) = 3 return abc</code
                  >
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Update and Add Properties</h2>
                <p>
                  Here is how we can update the last name as "Russell" and add a
                  new property called born with the value 1872.
                  <code class="language-text"
                    >match(abc) where ID(abc) = 3 set abc.lastName = "Russell",
                    abc.born = 1872 return abc</code
                  >
                </p>
                <p>
                  We can update using the property value as below.
                  <code class="language-text"
                    >match(abc{firstName:"Betrand"}) set abc.lastName =
                    "Russell", abc.firstName = "Bertrand", abc.born = 1872
                    return abc</code
                  >
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Label Manipulation</h2>
                <p>
                  <code class="language-text"
                    >match(abc{firstName:"Bertrand"}) set abc:British return
                    abc</code
                  >
                  will add the label "British" to all nodes with the first name
                  of Bertrand. Please note if the node already has the label as
                  British, this statement will not make any changes to that
                  node.
                </p>
                <p>
                  Now I want to remove the British label for the ID 3 alone.
                  Here is how I will go about it.
                  <code class="language-text"
                    >match(abc:British) where ID(abc) = 3
                    <strong>remove</strong> abc:British return abc</code
                  >
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Removing Properties</h2>
                <p>
                  If I want to remove the birth property for the ID 3 alone, I
                  will use the remove keyword along with dot operator to specify
                  the propery to be deleted.
                  <code class="language-text"
                    >match(abc:British) where ID(abc) = 3
                    <strong>remove</strong> abc.birth return abc</code
                  >
                </p>
                <p>
                  You can also remove the label and properties in a single go.
                  <code class="language-text"
                    >match(abc:British) where ID(abc) = 3
                    <strong>remove</strong> abc.birth, abc:British return
                    abc</code
                  >.
                </p>
                <p>
                  Above statement will remove the propery birth and the label
                  British.
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Deleting a node</h2>
                <p>
                  Deleting the node is simple. While retrieving, we use the
                  match... return combination. Now, for deleting we have to use
                  the match delete combination.
                  <code class="language-text"
                    >match(abc:British) where ID(abc) = 3
                    <strong>delete</strong> abc</code
                  >
                </p>
                <p>
                  <code class="language-text"
                    >match(abc:British) <strong>delete</strong> abc</code
                  >
                  will delete all the nodes with label as British.
                </p>
                <p>
                  <code class="language-text"
                    >match(abc) <strong>delete</strong> abc</code
                  >
                  will delete all nodes from that particular database. Above
                  deletes are working because the nodes do not have any
                  relationship. Things will be slightly different for nodes with
                  relationship.
                </p>
                <p>
                  If you want to delete the nodes without any label then you can
                  use this query.

                  <code class="language-text"
                    >match (node) WHERE size(labels(node)) = 0 delete node</code
                  >
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Relationships</h2>
                <p>
                  Let us now create a relationship between the nodes under
                  Author label to the nodes under Book label.
                  <code class="language-text"
                    >create (au:Author{firstName: "Robert", lastName: "Caro",
                    born: 1935}), (bk:Book{title: "The Power Broker", publisher:
                    "Knopf", born: 1974})<br />
                    <strong>create (au)-[:HAS_WRITTEN]-> (bk)</strong><br />
                    return au,bk<br /></code
                  >. The above code will create two nodes and establish a
                  HAS_WRITTEN relationship between them.
                </p>
                <p>
                  The above relationship can also be written like this. The
                  direction of the arrow matters.
                  <code class="language-text"
                    >create (bk)<-[:HAS_WRITTEN]- (au)</code
                  >
                </p>

                <p>
                  <code class="language-text"
                    >(au)-[:HAS_WRITTEN {pages:497}]->(bk)</code
                  >
                  will add pages property to the relationship.
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Relationship properties</h2>
                <p>
                  If you have the nodes created already, then use match to fetch
                  them using ID and create the relationship between them.<br />
                  <code class="language-text">
                    match (au:Author),(bk:Book)<br />
                    where ID(au) = 2 and ID(bk) = 6<br />
                    create (au)-[:HAS_WRITTEN {pages:497}]->(bk)<br />
                    return au,bk<br /> </code
                  ><br />
                  If you run the above script again, it will create another
                  duplicate relationship. So, we have to use merge instead of
                  create to avoid duplicates. <br />
                  <code class="language-text">
                    match (au:Author),(bk:Book)<br />
                    where ID(au) = 2 and ID(bk) = 6<br />
                    create (au)-[:HAS_WRITTEN {pages:497}]->(bk)<br />
                    return au,bk<br /> </code
                  ><br />
                  The merge will also work only as long as the properties are
                  the same. If you are adding a new property, merge will also
                  create a new relationship.
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Multiple Relationships</h2>
                <p>
                  You can create multiple relationships through a single command
                  as below.<br />
                  <code class="language-text">
                    create (au:Author{firstName: "Mathew", lastName: "Walker",
                    born: 1972}), (bk:Book{title: "Why we sleep", publisher:
                    "Allen", published: 2017}), (ct:City{City: "Berkeley",
                    state: "CA", Country: "US"})
                    <br />create (ct)<-[:LIVES_IN]-(au)-[:HAS_WRITTEN]->(bk)
                    <br />return au,bk<br /> </code
                  ><br />
                  <img src="/img/graph.jpg" />
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Fetching Relationships</h2>
                <p>
                  <code class="language-text">
                    match(au:Author)-[]-(node) where ID(au) = 10 return au, node
                  </code>
                  will fetch Author node with ID as 10, all the related nodes
                  which have any relationships with it in any direction.
                  (au:Author)-[]-(node) can also be written as
                  <code class="language-text"> (au:Author)<-[]->(node) </code>.
                  If you want to see only the nodes with relationship in the
                  outward direction you can use
                  <code class="language-text"> (au:Author)-[]->(node) </code>
                  and
                  <code class="language-text"> (au:Author)<-[]-(node) </code>
                  for inward directed nodes.
                </p>
                <p>
                  <code class="language-text">
                    match(au:Author)-[]-(node:City) where ID(au) = 10 return au,
                    node
                  </code>
                  will fetch Author node with ID as 10, only the related nodes
                  labeled as City and have relationships with it in any
                  direction.
                </p>
                <p>
                  We can also filter based on the type of the learning as below.
                  <code class="language-text"
                    >match(au:Author)-[:LIVES_IN]-(node) where ID(au) = 10
                    return au, node</code
                  >. Type of relationship can also take OR filter like this
                  <code class="language-text"
                    >(au:Author)-[:LIVES_IN | HAS_WRITTEN]-(node) </code
                  >. Notice there is no : for the type after pipe.
                </p>
                <p>
                  Relationships will not be displayed by default if the browser
                  settings is not configured so. If you want to see the
                  relationships irrespective of browser settings, then return
                  the alias for relationship as below
                  <code class="language-text"
                    >match(au:Author)<-[rel:LIVES_IN]->(node) where ID(au) = 10
                    return au, node, rel</code
                  >.
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">More on Multiples</h2>
                <p>
                  You can create multiple relationships through a single command
                  as below.<br />
                  <code class="language-text">
                    create (au:Author{firstName: "Doris", lastName: "Goodwin",
                    born: 1943}), <br />(bk1:Book{title: "Leadership",
                    publisher: "Simon", published: 2018}),<br />
                    (bk2:Book{title: "Team of Rivals", publisher: "Simon",
                    published: 2005}),<br />
                    (bk3:Book{title: "American Saga", publisher: "Martins",
                    published: 1987}),<br />
                    (ct:City{City: "Concord", state: "MA", Country: "US"})<br />
                    create
                    (ct)<-[:LIVES_IN]-(au)-[:HAS_WRITTEN]->(bk1),(bk2)<-[:HAS_WRITTEN]-(au)-[:HAS_WRITTEN]->(bk3)<br />
                    return au,bk1,bk2,bk3,ct<br /> </code
                  ><br />
                  <img src="/img/multi.jpg" />
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Update/Delete the properties</h2>
                <p>
                  Now, lets say we want to add few properties to the HAS_WRITTEN
                  relationship between two specific nodes. We will first
                  identitfy those two nodes through labels and properties (or
                  ID) like this:
                  <code class="language-text">
                    match(au:Author)<-[rel]->(node:Book {title:"Leadership"})
                    where ID(au) = 10 return au, node, rel
                  </code>
                </p>
                <p>
                  Then add the set clause to it.
                  <code class="language-text"
                    >match(au:Author)<-[rel]->(node:Book {title:"Leadership"})
                    where ID(au) = 10
                    <strong>rel.percent = "70%"</strong> return au, node,
                    rel</code
                  >.
                </p>
                <p>
                  And this is how we remove the properties
                  <code class="language-text">
                    match(au:Author)<-[rel]->(node:Book {title:"Leadership"})
                    where ID(au) = 10 remove rel.percent return au, node,
                    rel</code
                  >
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Multiple Relationships</h2>
                <p>
                  You can create multiple relationships through a single command
                  as below.<br />
                  <code class="language-text">
                    create (au:Author{firstName: "Mathew", lastName: "Walker",
                    born: 1972}), (bk:Book{title: "Why we sleep", publisher:
                    "Allen", published: 2017}), (ct:City{City: "Berkeley",
                    state: "CA", Country: "US"})
                    <br />create (ct)<-[:LIVES_IN]-(au)-[:HAS_WRITTEN]->(bk)
                    <br />return au,bk<br /> </code
                  ><br />
                </p>
              </div>
            </article>
          </li>
        </ul>
      </section>
    </main>

    <footer></footer>
  </body>
</html>
