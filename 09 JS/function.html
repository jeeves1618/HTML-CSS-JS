<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Functions</title>
    <link rel="preconnect" href="https://fonts.gstatic.com" />
    <link
      href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <link type="text/css" rel="stylesheet" href="css/topic.css" />
  </head>
  <body>
    <header id="main-header">
      <a href="index.html" id="logo">JavaScript</a>
      <nav>
        <ul>
          <li>
            <a
              href="https://jeeves1618.github.io/HTML-CSS-JS/30%20Librarian/index.html"
              >Books</a
            >
          </li>
          <li><a href="">Courses</a></li>
        </ul>
      </nav>
      <a href="#side-drawer" class="menu-btn"
        ><span></span><span></span><span></span
      ></a>
    </header>
    <aside id="side-drawer">
      <header id="sub-header">
        <a href="index.html" id="sublogo">Web Development with HTML and CSS</a>
        <a href="#" class="menu-btn"><span></span><span></span><span></span></a>
      </header>
      <nav>
        <ul>
          <li>
            <a
              href="https://jeeves1618.github.io/HTML-CSS-JS/30%20Librarian/index.html"
              >Books</a
            >
          </li>
          <li><a href="">Courses</a></li>
        </ul>
      </nav>
    </aside>
    <main>
      <h1>Functions</h1>
      <section id="latest-products">
        <ul>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">New in ES6</h2>
                <p>
                  Default parameters are allowed since ES6.
                  <span class="js-text"
                    >const calcAge = function (birth, now = 2023) {...}</span
                  >
                  can be called with only one argument as in
                  <span class="js-text">calcAge(1990)</span>. Also, note that
                  the default value can be an expression or use the previously
                  defaulted parameter(s).
                </p>
                <ol class="js-text">
                  <li>
                    const calcAge = function (birth, now = 20 * 100) {...}
                  </li>
                  <li>
                    const calcAge = function (birth = 1908, now = birth + 16)
                    {...}
                  </li>
                </ol>
                <p>
                  Only thing is you cannot skip the arguments in the middle when
                  the last argument needs to be overridden. You can pass
                  undefined there.
                </p>
                <ol class="js-text">
                  <li>const func = function (a, b, c=10) {...}</li>
                  <li>func(10,undefined,20);</li>
                </ol>
                <p>You cannot omnit b and pass 10 and 20.</p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">First Class Functions</h2>
                <p>
                  Functions are just another type of objects in JavaScript. You
                  can invoke functions on functions. Since, objects are values,
                  functions are also values and can be stored in variables.
                </p>
                <ol class="js-text">
                  <li>const greet = (person) => {</li>
                  <li>console.log("hey " + person);</li>
                  <li>};</li>
                </ol>
                <p>And you can pass this function to another function.</p>
                <ol class="js-text">
                  <li>const greeter = (fn, person) => {</li>
                  <li>fn(person);</li>
                  <li>};</li>
                  <li>greeter(greet, "Universe");</li>
                </ol>
                <p>
                  Here the greet function is passed as an argument to greeter
                  function and, hence, the greet function will become the
                  <strong>callback function</strong> and the greeter function
                  will become the <strong>higher order function</strong>.
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Returning Functions</h2>
                <p>You can return a function like this.</p>
                <ol class="js-text">
                  <li>const fun = function (greet) {</li>
                  <li>&nbsp;return function (name) {</li>
                  <li>&nbsp;console.log(`${greet} ${name}`);</li>
                  <li>&nbsp;};</li>
                  <li>};</li>
                  <li></li>
                  <li>const greeter = fun("Hello");</li>
                  <li>greeter("World");</li>
                </ol>
                <p>This will print Hello World</p>

                <p>
                  The awkward looking
                  <span class="js-text">fun("Hello")("Universe");</span> will
                  also work. Remember fun("Hello") will return a function name
                  and we are executing that function by passing a parameter
                  through ("Universe").
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Methods</h2>
                <p>
                  Functions defined within an object, like trip, are methods.
                </p>
                <ol class="js-text">
                  <li>const myYacht = {</li>
                  <li>&nbsp;model: "Sunseeker 95",</li>
                  <li>&nbsp;trips: [],</li>
                  <li>&nbsp;const trip(rangeInNM, fuelInL) {</li>
                  <li>&nbsp;&nbsp;let tripAdvice = `${this.model} sailed ${</li>
                  <li>&nbsp;&nbsp;&nbsp;&nbsp;rangeInNM * 1.852</li>
                  <li>
                    &nbsp;&nbsp;} Kilometers, consuming ${fuelInL} liters of
                    Disel and providing a mileage of ${
                  </li>
                  <li>&nbsp;&nbsp;&nbsp;&nbsp;(rangeInNM * 1.852) / fuelInL</li>
                  <li>&nbsp;&nbsp;} KMPL`;</li>
                  <li>&nbsp;&nbsp;this.trips.push(tripAdvice);</li>
                  <li>&nbsp;&nbsp;return tripAdvice;</li>
                  <li>&nbsp;},</li>
                  <li>};</li>
                  <li></li>
                  <li>console.log(myYacht.trip(1400, 12000));</li>
                </ol>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Call and Apply</h2>
                <p>
                  Now, I add one more yacht to my collection. I don't want to
                  rewrite the entire object again.
                </p>
                <ol class="js-text">
                  <li>const myNewYacht = {</li>
                  <li>&nbsp;model: "Sunseeker 116",</li>
                  <li>&nbsp;trips: [],</li>
                  <li>};</li>
                </ol>
                <p>
                  So, I create another object for my new yacht with place holder
                  for storing the yacht specific details. I want to reuse the
                  method defined within myYacht.
                </p>

                <p>
                  If I just invoke the function
                  <span class="js-text">console.log(trip(1600, 14450));</span>
                  it will give me this error 'ReferenceError: trip is not
                  defined'. So, we get the reference to the method from myYacht
                  object using
                  <span class="js-text">const trip = myYacht.trip;</span>. Then
                  we invoke it by passing the new object and aruguments to the
                  call function. This will point the this operator in the trip
                  method to point to the myNewYacht object.<span class="js-text"
                    >console.log(trip.call(myNewYacht, 1600, 14450));</span
                  >
                  You can also use apply instead of call, if you pack the
                  arguments into an array.
                </p>
                <ol class="js-text">
                  <li>const spec = [1600, 14450];</li>
                  <li>console.log(trip.apply(myNewYacht, spec));</li>

                  <li>};</li>
                </ol>
                <p>
                  Also, once you have got the reference of the method once, you
                  can use that same reference variable for multiple objects.
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Binding a Method</h2>
                <p>
                  Call and Apply invoke the method right away with the object
                  passed as the parameter. But, bind will pass a function
                  reference that you can use later to invoke the function.
                </p>
                <ol class="js-text">
                  <li>const yacht095 = trip.bind(myYacht);</li>
                  <li>const yacht116 = trip.bind(myNewYacht);</li>
                  <li>const yacht131 = trip.bind(mySuperYacht);</li>
                  <li>console.log(yacht095(2000, 10000));</li>
                  <li>console.log(yacht116(2000, 12000));</li>
                  <li>console.log(yacht131(2000, 14000));</li>
                </ol>
                <p>
                  Well, the first parameter that I pass is always 2000. Yes, we
                  don't have to repeat that, we can bind the object with the
                  first parameter as 2000.
                </p>
                <ol class="js-text">
                  <li>const yacht095 = trip.bind(myYacht, 2000);</li>
                  <li>const yacht116 = trip.bind(myNewYacht, 2000);</li>
                  <li>const yacht131 = trip.bind(mySuperYacht, 2000);</li>
                  <li>console.log(yacht095(10000));</li>
                  <li>console.log(yacht116(12000));</li>
                  <li>console.log(yacht131(14000));</li>
                </ol>
                <p>
                  This way of predefining part of the arguments to a function is
                  called partial application.
                </p>
                <p>
                  Bind method has one more very practical application. It is
                  related to where the 'this' operator points to, when a
                  function gets invoked on a click event from the DOM.
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Binding DOM</h2>
                <p>
                  Let me add a new property and a method to the myYacht object.
                </p>
                <ol class="js-text">
                  <li>myYacht.count = 1;</li>
                  <li>myYacht.buyNewYacht = function () {</li>
                  <li>&nbsp;&nbsp;this.count++;</li>
                  <li>&nbsp;&nbsp;console.log(this.count);</li>
                  <li>};</li>
                  <li>
                    document.querySelector(".button"). addEventListener('click',
                    myYacht.buyNewYacht)
                  </li>
                </ol>
                <p>
                  The above call back from addEventListener will not work.
                  Because, the 'this' operator inside the buyNewYacht method
                  will not point to myYacht object when the function is invoked
                  from DOM. Instead, 'this' will point to DOM object and there
                  will not be a count variable defined there.
                </p>
                <p>
                  So, we have to force 'this' to point to myYacht object. We
                  cannot use call or apply since they will execute the function
                  right away. We do not want to execute the callback right away.
                  We will use the bind method instead.
                </p>
                <ol class="js-text">
                  <li>document.querySelector (".button").addEventListener</li>
                  <li>('click', myYacht.buyNewYacht.bind(myYacht));</li>
                </ol>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Partial Application</h2>
                <p>
                  I want to create a function that takes the sale value and tax
                  rate as inputs and computes the tax amount.
                </p>
                <ol class="js-text">
                  <li>let compTax = (rate, value) => value * (1 + rate);</li>
                </ol>
                <p>
                  We will invoke the function by passing two parameters.
                  <span class="js-text">compTax(0.12, 1000)</span> Lets imagine
                  the above function is much more complicated than above. So,
                  when I create a function for VAT, where only change is rate
                  should not be provided as input, but taken as a previously
                  defined constant, we can bind the new function to the
                  <span class="js-text">compTax</span> function. Remember, in
                  all previous instances we bound the new function to a method
                  defined within an object. Now, we are binding them to a stand
                  alone function. So, in the place of providing an object, we
                  will provide null.
                </p>
                <ol class="js-text">
                  <li>let compVATax = compTax.bind(null, 0.25);</li>
                </ol>
                <p>
                  Now, the <span class="js-text">compVATax</span> function will
                  be invoked with only one parameter since the rate is
                  predefined as in <span class="js-text">compVATax(1000)</span>.
                  It is important that predefined argument(s) are in the
                  beginning of the function that is being bound.
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">IIFE</h2>
                <p>
                  If you want to write a function that should be invoked only
                  once, you will use the immedietly invoked function
                  expressions. For instance, the below function can not enforce
                  the caller to not call again.
                </p>
                <ol class="js-text">
                  <li>const runOnce = function () {</li>
                  <li>&nbsp;&nbsp;console.log(</li>
                  <li>&nbsp;&nbsp;"This should never run again!"</li>
                  <li>&nbsp;&nbsp;);</li>
                  <li>};</li>

                  <li>runOnce();</li>
                </ol>
                <p>
                  Now if I made it unavailable to other by not giving a name to
                  invoke, JS will give this error - "SyntaxError: Function
                  statements require a function name"
                </p>
                <ol class="js-text">
                  <li>function () {</li>
                  <li>&nbsp;&nbsp;console.log(</li>
                  <li>&nbsp;&nbsp;"This won't work!"</li>
                  <li>&nbsp;&nbsp;);</li>
                  <li>};</li>
                </ol>
                <p>
                  So, we will wrap it in () to make JS believe that it is an
                  expression. But, now the problem is, it won't get invoked.
                </p>
                <ol class="js-text">
                  <li>(function () {</li>
                  <li>&nbsp;&nbsp;console.log(</li>
                  <li>&nbsp;&nbsp;"This won't work!"</li>
                  <li>&nbsp;&nbsp;);</li>
                  <li>};)</li>
                </ol>
                <p>
                  If you add an () next to the above function, you got yourself
                  an iffy
                  <a
                    href="https://github.com/jeeves1618/NodeJS/blob/master/02%20JS%20Refresher/iiefunctions.js"
                    target="_blank"
                    >(an example here).</a
                  >
                </p>
                <ol class="js-text">
                  <li>(function () {</li>
                  <li>&nbsp;&nbsp;console.log(</li>
                  <li>&nbsp;&nbsp;"This won't work!"</li>
                  <li>&nbsp;&nbsp;);</li>
                  <li>};)()</li>
                </ol>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Closures</h2>
                <p>
                  Closure is an underlying JavaScript capability which gets
                  invoked when a function returns another function. Once the
                  parent function returns the child function, it goes out of
                  execution context and code outside that function cannot use
                  the variables defined inside the parent function.
                </p>
                <p>
                  But, the child function returned by the parent function will
                  continue to have access to the variable environment of the
                  parent function. This is called closure.
                </p>
                <ol class="js-text">
                  <li>const scoreEngineNext = function () {</li>
                  <li>&nbsp;&nbsp;let player1 = null,</li>
                  <li>&nbsp;&nbsp;player2 = null;</li>
                  <li></li>
                  <li>&nbsp;&nbsp;let player1Runs = 0;</li>
                  <li>&nbsp;&nbsp;let player2Runs = 0;</li>
                  <li></li>
                  <li>
                    &nbsp;&nbsp;function coreEngine(player, runsScoredInTheBall)
                    {
                  </li>
                  <li>&nbsp;&nbsp;&nbsp;&nbsp;if (player1 === null) {</li>
                  <li>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;player1 =
                    player;
                  </li>
                  <li>
                    &nbsp;&nbsp;&nbsp;&nbsp;} else if (player2 === null &&
                    player1 !== player) {
                  </li>
                  <li>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;player2 =
                    player;
                  </li>
                  <li>&nbsp;&nbsp;&nbsp;&nbsp;}</li>
                  <li></li>
                  <li>
                    &nbsp;&nbsp;&nbsp;&nbsp;if (player === player1) player1Runs
                    = player1Runs + runsScoredInTheBall;
                  </li>
                  <li>
                    &nbsp;&nbsp;&nbsp;&nbsp;if (player === player2) player2Runs
                    = player2Runs + runsScoredInTheBall;
                  </li>
                  <li>
                    &nbsp;&nbsp;&nbsp;&nbsp;console.log(`${player1} Not Out
                    ${player1Runs}`);
                  </li>
                  <li>
                    &nbsp;&nbsp;&nbsp;&nbsp;console.log(`${player2} Not Out
                    ${player2Runs}`);
                  </li>
                  <li>&nbsp;&nbsp;}</li>
                  <li></li>
                  <li>&nbsp;&nbsp;return coreEngine;</li>
                  <li>};</li>
                </ol>
                <p>
                  scoreEngineNext is the parent function here. coreEngine is
                  created within and returned by the parent. coreEngine will
                  have access to the scoreEngineNext's variable if it is invoked
                  outside the function
                  <a
                    href="https://github.com/jeeves1618/NodeJS/blob/master/02%20JS%20Refresher/closures.js"
                    target="_blank"
                    >(an example here)</a
                  >
                </p>
              </div>
            </article>
          </li>
        </ul>
      </section>
    </main>

    <footer></footer>
  </body>
</html>
