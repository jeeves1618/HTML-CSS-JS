<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Clean Architecture</title>
    <link rel="preconnect" href="https://fonts.gstatic.com" />
    <link
      href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <link type="text/css" rel="stylesheet" href="css/topic.css" />
  </head>
  <body>
    <header id="main-header">
      <a href="index.html" id="logo">System Design</a>
      <nav>
        <ul>
          <li>
            <a
              href="https://jeeves1618.github.io/HTML-CSS-JS/30%20Librarian/index.html"
              >Books</a
            >
          </li>
          <li><a href="">Courses</a></li>
        </ul>
      </nav>
      <a href="#side-drawer" class="menu-btn"
        ><span></span><span></span><span></span
      ></a>
    </header>
    <aside id="side-drawer">
      <header id="sub-header">
        <a href="refresher.html" id="sublogo">Clean Architecture</a>
        <a href="#" class="menu-btn"><span></span><span></span><span></span></a>
      </header>
      <nav>
        <ul>
          <li>
            <a
              href="https://jeeves1618.github.io/HTML-CSS-JS/30%20Librarian/index.html"
              >Books</a
            >
          </li>
          <li><a href="">Courses</a></li>
        </ul>
      </nav>
    </aside>
    <main>
      <h1>Clean Architecture</h1>
      <section></section>
      <section id="latest-products">
        <ul>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Two Values</h2>
                <p>
                  Every software system provides two values to its stake
                  holders, behaviour and structure. Behaviour is dictated by the
                  business requirements. But, Developers tend to focus more on
                  behaviour and less on structure. Because, the programs we
                  write are expected to behave in a specific manner. It becomes
                  a matter of urgency if they don't behave in that way.
                  Structure, in spite of its importance, is never enforced.
                </p>

                <p>
                  A 'software' is supposed to be soft. That is, it should be
                  easy to change. The difficulty in making the change should be
                  proprtional to the scope of the change, not to the shape of
                  the change. The structure determines impact of shape on a
                  change.
                  <strong
                    >Is it more important for the software system to work or is
                    it more important for the software system to be accomodative
                    of changes?</strong
                  >
                </p>
                <p>
                  If we have a program that works, but is impossible to change,
                  then it will stop working when there is a change in
                  requirement. Unless you are living in a world of certainity,
                  where you know how the program should behave for the next 100
                  years, you should consider shape agnostic structure of
                  software programs to be more important than behaviour.
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Matrix</h2>

                <img src="./img/Matrix.jpg" />
                <p>
                  The strucuture of the code is in the first two positions of
                  priority and the behaviour of code is in the first and the
                  third positions of priority. The mistake that we often make is
                  to elevate the priority 3 items to priority 1. This leads to
                  ignoring the important architectural elements of the system in
                  favor of the unimportant features. Since, business is detached
                  from the architecture of a system, it is the responsibility of
                  the developers to assert the importance of structure over
                  behaviour.
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Three Paradigms</h2>
                <p>
                  The three paradigms in programming are
                  <strong
                    >structured, object oriented and functional
                    programming</strong
                  >. Dijkstra prohibited the go to statements and invented
                  structured programming â€”in which programs flow from top to
                  bottom following a hierarchical model. Structured programming
                  imposes discipline on direct flow of control.
                </p>
                <p>
                  Object Oriented Programming originated when the developers
                  realized the variables in the stack can be be stored in a heap
                  and can be reused after the function returns. The function can
                  be used as the constructor of the class. Object Oriented
                  Programming imposes discipline on indirect transfer of
                  control.
                </p>
                <p>
                  Functional programming is an extension of lambda calculus. The
                  foundation of lambda calculus is the immutability of
                  variables. Functional imposes discipline upon assignment of
                  values. Most functional languages will have restricted means
                  of assigning values.
                </p>
                <p>
                  The three paradigms take away go to statements, function
                  pointers and assignment. There is probably nothing more to
                  take away from the developers and that may be why we aren't
                  seeing any new paradigms.
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Structured Programming</h2>
                <p>
                  Dijkstra found out that certain usage of 'go to' statement
                  prevents the decomposition of a module recursively in to
                  smaller units. This prevents developers from employing divide
                  and conquer approach of reducing system complexity.
                </p>
                <p>
                  So, Edgar Dijkstra published a paper stating
                  <a
                    href="https://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf"
                    target="_blank"
                    >Go To statement is harmful</a
                  >. This led to the removal for 'go to' statements from modern
                  languages and allowed the programmers to decompose a large
                  scale problems into small functions. Dijkstra initially
                  thought of strucutred programming to be accompanied by
                  mathematical euclidean proofs. But, programming moved towards
                  verification scientific observations (a.k.a tests) in its
                  further evolution.
                </p>
                <p>
                  Dijkstra once said a test can prove the presence of bugs, but
                  not the absence of them. A program can be proven incorrect by
                  a test, but it cannot be proven correct by a test. So,
                  software development is not a mathematical endevor. Rather, it
                  is a science where we show corrects by failing to prove
                  incorrects.
                </p>
                <p>
                  The above proof of incorrects is possible only on provable
                  sttructured programs. You cannot show corrects by failing to
                  prove incorrects in a code full of 'go to' statements.
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Object Oriented Programming</h2>
                <p>
                  Dijkstra found out that certain usage of 'go to' statement
                  prevents the decomposition of a module recursively in to
                  smaller units. This prevents developers from employing divide
                  and conquer approach of reducing system complexity.
                </p>
                <p>
                  So, Edgar Dijkstra published a paper stating
                  <a
                    href="https://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf"
                    target="_blank"
                    >Go To statement is harmful</a
                  >. This led to the removal for 'go to' statements from modern
                  languages and allowed the programmers to decompose a large
                  scale problems into small functions. Dijkstra initially
                  thought of strucutred programming to be accompanied by
                  mathematical euclidean proofs. But, programming moved towards
                  verification scientific observations (a.k.a tests) in its
                  further evolution.
                </p>
                <p>
                  Dijkstra once said a test can prove the presence of bugs, but
                  not the absence of them. A program can be proven incorrect by
                  a test, but it cannot be proven correct by a test. So,
                  software development is not a mathematical endevor. Rather, it
                  is a science where we show corrects by failing to prove
                  incorrects.
                </p>
                <p>
                  The above proof of incorrects is possible only on provable
                  sttructured programs. You cannot show corrects by failing to
                  prove incorrects in a code full of 'go to' statements.
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Object Oriented Design Goals</h2>
                <p>
                  The three major goals of object oriented programming are
                  robustness, adaptability, and reusability.
                </p>
                <p>
                  We always program for the expected behaviour. In addition, we
                  want software to be <strong>robust</strong>, that is, capable
                  of handling unexpected inputs that are not explicitly defined
                  for its application. For example, if a program is expecting a
                  positive integer (perhaps representing the price of an item)
                  and instead is given a negative integer, then the program
                  should be able to recover gracefully from this error.
                </p>
                <p>
                  Software needs to be able to evolve over time in response to
                  changing conditions in its environment. Thus, another
                  important goal of quality software is that it achieves
                  <strong>adaptability</strong> (also called evolvability).
                  Related to this concept is portability, which is the ability
                  of software to run with minimal change on different hardware
                  and operating system platforms.
                </p>
                <p>
                  Going hand in hand with adaptability is the desire that
                  software be <strong>reusable</strong>, that is, the same code
                  should be usable as a component of different systems in
                  various applications. Developing quality software can be an
                  expensive enterprise, and its cost can be offset somewhat if
                  the software is designed in a way that makes it easily
                  reusable in future applications.
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">OOD - Principle 1 - Abstraction</h2>
                <p>
                  The above Object Oriented Design goals are achieved through
                  three important principles of object oriented programming.
                  They are abstraction, encapsulation and modularity.
                </p>
                <p>
                  We always program for the expected behaviour. In addition, we
                  want software to be <strong>robust</strong>, that is, capable
                  of handling unexpected inputs that are not explicitly defined
                  for its application. For example, if a program is expecting a
                  positive integer (perhaps representing the price of an item)
                  and instead is given a negative integer, then the program
                  should be able to recover gracefully from this error.
                </p>
                <p>
                  Software needs to be able to evolve over time in response to
                  changing conditions in its environment. Thus, another
                  important goal of quality software is that it achieves
                  <strong>adaptability</strong> (also called evolvability).
                  Related to this concept is portability, which is the ability
                  of software to run with minimal change on different hardware
                  and operating system platforms.
                </p>
                <p>
                  Going hand in hand with adaptability is the desire that
                  software be <strong>reusable</strong>, that is, the same code
                  should be usable as a component of different systems in
                  various applications. Developing quality software can be an
                  expensive enterprise, and its cost can be offset somewhat if
                  the software is designed in a way that makes it easily
                  reusable in future applications.
                </p>
              </div>
            </article>
          </li>
        </ul>
      </section>
    </main>

    <footer></footer>
  </body>
</html>
